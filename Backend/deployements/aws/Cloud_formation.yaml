AWSTemplateFormatVersion: '2010-09-09'
Description: CloudFormation template for deploying Lambda function and API Gateway for user authentication

Parameters:
  Stage:
    Type: String
    Default: dal-vacation-home-cf
  RoleARN:
    Type: String
    Default: "arn:aws:iam::705544929821:role/service-role/GetSummerCourses-role-a3xrd2hc"
  Region:
    Type: String
    Default: "us-east-1"

Resources:

  ApiGatewayRestApi:
    Type: 'AWS::ApiGateway::RestApi'
    Properties:
      Name: 'DalVacationHomeCF'
      ApiKeySourceType: "HEADER"
      EndpointConfiguration:
        Types:
          - "REGIONAL"


  #Done
  FirstFactorAuthentication:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: 'index.handler'
      Role: !Ref RoleARN
      Code:
        ZipFile: |
          const { CognitoIdentityProviderClient, InitiateAuthCommand, AdminListGroupsForUserCommand } = require('@aws-sdk/client-cognito-identity-provider');
          const { DynamoDBClient, UpdateItemCommand, GetItemCommand } = require("@aws-sdk/client-dynamodb");
          const { DynamoDBDocumentClient, UpdateCommand, GetCommand } = require("@aws-sdk/lib-dynamodb");
          const { SNSClient, PublishCommand } = require("@aws-sdk/client-sns");

          const dbClient = new DynamoDBClient({ region: process.env.AWS_REGION });
          const cognitoClient = new CognitoIdentityProviderClient({ region: process.env.AWS_REGION });
          const ddbDocClient = DynamoDBDocumentClient.from(dbClient);

          const snsClient = new SNSClient({});

          const poolData = {
            UserPoolId: "us-east-1_D8LhOZMJq",
            ClientId: "7obkafbfl095gprlo6gli6je55",
          };

          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "OPTIONS,GET"
              }
            };

            const { email, password } = event.queryStringParameters;

            if (!email || !password) {
              return {
                ...response,
                statusCode: 400,
                body: JSON.stringify({ message: 'Email and password are required' }),
              };
            }

            try {
              // Authenticate user and get tokens using the login function
              const tokens = await login(email, password);

              // Fetch encrypted secret key and encryption shift from DynamoDB
              const getParams = {
                TableName: 'User',
                Key: { email },
              };

              const data = await ddbDocClient.send(new GetCommand(getParams));
              if (!data.Item) {
                return {
                  ...response,
                  statusCode: 404,
                  body: JSON.stringify({ message: 'User not found' }),
                };
              }
        
              const { cityBorn, favoriteColor, favoriteSports, secretKey, topicArn, firstName} = data.Item;


              // Check if user is verified
              // const userResponse = await getUserAttributes(email);

              // Check if security questions and secret key exist
              // const { cityBorn, favoriteColor, favoriteSports, secretKey, firstName } = userResponse.Item;
    
              if (!cityBorn || !favoriteColor || !favoriteSports || !secretKey || !firstName) {
                return {
                  ...response,
                  statusCode: 400,
                  body: JSON.stringify({ message: 'Security questions and secret key are required for your account.' }),
                };
              }

              // Check if user belongs to required groups
              const groupInfo = await checkUserGroups(email);

              // Update user's tokens in DynamoDB
              const updateTokensParams = {
                TableName: process.env.USERS_TABLE_NAME,
                Key: {
                  email: { S: email },
                },
                UpdateExpression: "SET accessToken = :accessToken, refreshToken = :refreshToken",
                ExpressionAttributeValues: {
                  ":accessToken": { S: tokens.accessToken },
                  ":refreshToken": { S: tokens.refreshToken },
                },
              };

              try {
                await dbClient.send(new UpdateItemCommand(updateTokensParams));
                console.log("Tokens updated in DynamoDB for user:", email);
              } catch (updateError) {
                console.error("Error updating tokens in DynamoDB:", updateError);
                return {
                  ...response,
                  statusCode: 400,
                  body: { message: 'Error updating tokens in DynamoDB.' },
                };
              }
            
              // if(topicArn){
              //     // Send registration success email via SNS
              //   const publishParams = {
              //     TopicArn: String(topicArn),
              //     Message: `Welcome to Dal-Vacation-Home, ${firstName}. To get started, log in with your credentials and start exploring our services.`,
              //     Subject: 'User logged in',
              //   };
          
              //   try {
              //     await snsClient.send(new PublishCommand(publishParams));
              //   } catch (snsError) {
              //     console.error('Error sending SNS message:', snsError);
              //     // Handle the error appropriately, such as returning an error response
              //     return {
              //       ...response,
              //       statusCode: 500,
              //       body: { message: 'Error sending registration success email' }
              //     };
              //   }
              // }
              // Return successful response with tokens and group information
              
              
              const userData = await ddbDocClient.send(new GetCommand(getParams));
              if (!userData.Item) {
                return {
                  ...response,
                  statusCode: 404,
                  body: JSON.stringify({ message: 'User not found' }),
                };
              }


              return {
                ...response,
                statusCode: 200,
                body:JSON.stringify({
                  groups: groupInfo,
                  user: userData.Item
                 }),
              };
            } catch (error) {
              console.error('Login failed:', error);
              // Return error response
              return {
                ...response,
                statusCode: 500,
                body: JSON.stringify({ message: 'Error during login.' + error.message }),
              };
            }
          };

          const login = async (email, password) => {
            const initiateAuthParams = {
              AuthFlow: 'USER_PASSWORD_AUTH',
              ClientId: poolData.ClientId,
              AuthParameters: {
                USERNAME: email,
                PASSWORD: password,
              },
            };

            try {
              // Initiate authentication
              const authResponse = await cognitoClient.send(new InitiateAuthCommand(initiateAuthParams));

              // Extract tokens
              const tokens = {
                accessToken: authResponse.AuthenticationResult.AccessToken,
                idToken: authResponse.AuthenticationResult.IdToken,
                refreshToken: authResponse.AuthenticationResult.RefreshToken,
              };

              return tokens;
            } catch (error) {
              console.error("Error during user authentication:", error);
              throw error;
            }
          };

          const getUserAttributes = async (email) => {
            const params = {
              TableName: process.env.USERS_TABLE_NAME,
              Key: {
                email: { S: email },
              },
            };

            try {
              const data = await dbClient.send(new GetItemCommand(params));
              return data;
            } catch (error) {
              console.error("Error fetching user attributes:", error);
              throw error;
            }
          };

          const checkUserGroups = async (email) => {
            const params = {
              UserPoolId: poolData.UserPoolId,
              Username: email,
            };

            try {
              const groupsResponse = await cognitoClient.send(new AdminListGroupsForUserCommand(params));
              const groups = groupsResponse.Groups.map(group => group.GroupName);

              return groups;
            } catch (error) {
              console.error("Error checking user groups:", error);
              throw error;
            }
          };
      Runtime: 'nodejs20.x'
      Timeout: 30
      Environment:
        Variables:
          USERS_TABLE_NAME: "User"

  ApiGatewayResourceUserAuth:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'login'

  ApiGatewayMethodUserAuth:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceUserAuth
      HttpMethod: GET
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.querystring.email": true
        "method.request.querystring.password": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'GET,POST,PUT,DELETE,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceUserAuth
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${FirstFactorAuthentication.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,PUT,DELETE,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  UserAuthFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt FirstFactorAuthentication.Arn
      Principal: apigateway.amazonaws.com

  ApiGatewayMethodOptionsUserAuth:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceUserAuth
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceUserAuth
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'GET,POST,PUT,DELETE,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"


  #Done
  ThirdFactorAuthentication:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: 'index.handler'
      Role: !Ref RoleARN
      Code:
        ZipFile: |
          const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
          const { DynamoDBDocumentClient, GetCommand } = require("@aws-sdk/lib-dynamodb");
          const { SNSClient, PublishCommand } = require("@aws-sdk/client-sns");

          const ddbClient = new DynamoDBClient({});
          const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);
          const snsClient = new SNSClient({});

          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "OPTIONS,GET"
              }
            };

            const { email, secretKeyVerify } = event.queryStringParameters;

            // Validate input
            if (!email || !secretKeyVerify) {
              return {
                ...response,
                statusCode: 400,
                body: JSON.stringify({ message: 'Email and secretKey are required' }),
              };
            }

            // Fetch encrypted secret key and encryption shift from DynamoDB
            const getParams = {
              TableName: 'User',
              Key: { email },
            };

            try {
              const data = await ddbDocClient.send(new GetCommand(getParams));

              if (!data.Item) {
                return {
                  ...response,
                  statusCode: 404,
                  body: JSON.stringify({ message: 'User not found' }),
                };
              }

              const { secretKey, shiftValue, topicArn, firstName } = data.Item;

              // Decrypt the secret key using Caesar cipher and the shift value from DynamoDB
              const decryptedSecretKey = decryptCaesarCipher(secretKey, shiftValue);

              // Compare decrypted secret key with user-provided secret key
              if (secretKeyVerify !== decryptedSecretKey) {
                return {
                  ...response,
                  statusCode: 403,
                  body: JSON.stringify({ message: 'Incorrect secret key' }),
                };
              }

              if (topicArn) {
                const publishParams = {
                  TopicArn: topicArn,
                  Message: `Welcome to Dal-Vacation-Home, ${firstName}. \n You are now logged in. Start using our services.`,
                  Subject: 'User Login at Dal-Vacation-Home',
                };

                try {
                  await snsClient.send(new PublishCommand(publishParams));
                } catch (snsError) {
                  console.error('Error sending SNS message:', snsError);
                  // Handle the error appropriately, such as returning an error response
                  // return {
                  //   ...response,
                  //   statusCode: 500,
                  //   body: { message: 'Error sending registration success email' }
                  // };
                }
              }

              return {
                ...response,
                statusCode: 200,
                body: JSON.stringify({ message: 'Authentication successful' }),
              };
            } catch (error) {
              console.error('Error fetching data from DynamoDB:', error);
              return {
                ...response,
                statusCode: 500,
                body: JSON.stringify({ message: 'Error fetching data from DynamoDB' }),
              };
            }
          };

          // Decrypts the Caesar cipher encrypted text
          function decryptCaesarCipher(encryptedText, shift) {
            const alphabet = 'abcdefghijklmnopqrstuvwxyz';

            let decryptedText = '';

            for (let i = 0; i < encryptedText.length; i++) {
              const char = encryptedText[i];
              const index = alphabet.indexOf(char.toLowerCase());

              if (index === -1) {
                // If character is not in the alphabet (like spaces or punctuation), keep it unchanged
                decryptedText += char;
              } else {
                // Decrypt the character using the shift
                let decryptedIndex = (index - shift + alphabet.length) % alphabet.length;
                if (decryptedIndex < 0) {
                  decryptedIndex += alphabet.length; // Handle negative indices
                }
                decryptedText += char === char.toUpperCase() ? alphabet[decryptedIndex].toUpperCase() : alphabet[decryptedIndex];
              }
            }

            return decryptedText;
          }

      Runtime: 'nodejs20.x'
      Timeout: 30
      Environment:
        Variables:
          USERS_TABLE_NAME: "User"

  SecretKeyVerificationFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt ThirdFactorAuthentication.Arn
      Principal: apigateway.amazonaws.com

  ApiGatewayResourceSecretKeyVerification:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'secret-key-verify'

  ApiGatewayMethodSecretKeyVerification:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceSecretKeyVerification
      HttpMethod: GET
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.querystring.email": true
        "method.request.querystring.secretKeyVerify": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceSecretKeyVerification
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ThirdFactorAuthentication.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  ApiGatewayMethodOptionsSecretKeyVerification:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceSecretKeyVerification
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceSecretKeyVerification
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'GET,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"


  #Done
  SecondFactorAuthentication:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: 'index.handler'
      Role: !Ref RoleARN
      Code:
        ZipFile: |
         const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
          const { DynamoDBDocumentClient, UpdateCommand, GetCommand } = require("@aws-sdk/lib-dynamodb");
          const { SNSClient, PublishCommand } = require("@aws-sdk/client-sns");
          
          const client = new DynamoDBClient({});
          const ddbDocClient = DynamoDBDocumentClient.from(client);
          const snsClient = new SNSClient({});
          
          // Caesar Cipher encryption function
          const caesarCipherEncrypt = (text, shift) => {
            return text.split('').map(char => {
              const code = char.charCodeAt();
              // Encrypt letters only
              if (char >= 'a' && char <= 'z') {
                return String.fromCharCode(((code - 97 + shift) % 26) + 97);
              } else if (char >= 'A' && char <= 'Z') {
                return String.fromCharCode(((code - 65 + shift) % 26) + 65);
              }
              return char;
            }).join('');
          };
          
          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "OPTIONS,POST"
              }
            };
          
            const eventData = JSON.parse(event.body);
            const action = eventData.action;
          
            if (action === "add") {
              console.log(eventData.body);
              const { email, favoriteColor, cityBorn, favoriteSports, secretKey } = eventData.body;
          
              // Validate input
              if (!email || !favoriteColor || !cityBorn || !favoriteSports || !secretKey) {
                return {
                  ...response,
                  statusCode: 400,
                  body: JSON.stringify({ message: 'Email, favorite color, city born, favorite sports, and secret key are required' }),
                };
              }
          
              // Caesar cipher shift value
              const shift = 3; // You can change this value as needed
              const encryptedKey = caesarCipherEncrypt(secretKey, shift);
          
              // Construct the update expression
              let updateExpression = 'SET';
              const expressionAttributeValues = {};
          
              if (favoriteColor) {
                updateExpression += ' favoriteColor = :favoriteColor,';
                expressionAttributeValues[':favoriteColor'] = favoriteColor;
              }
              if (cityBorn) {
                updateExpression += ' cityBorn = :cityBorn,';
                expressionAttributeValues[':cityBorn'] = cityBorn;
              }
              if (favoriteSports) {
                updateExpression += ' favoriteSports = :favoriteSports,';
                expressionAttributeValues[':favoriteSports'] = favoriteSports;
              }
              updateExpression += ' secretKey = :secretKey, shiftValue = :shiftValue,';
              expressionAttributeValues[':secretKey'] = encryptedKey;
              expressionAttributeValues[':shiftValue'] = shift;
          
              // Remove trailing comma
              updateExpression = updateExpression.slice(0, -1);
          
              const params = {
                TableName: 'User',
                Key: { email },
                UpdateExpression: updateExpression,
                ExpressionAttributeValues: expressionAttributeValues,
                ReturnValues: "UPDATED_NEW"
              };
          
              // Fetch encrypted secret key and encryption shift from DynamoDB
              const getParams = {
                TableName: 'User',
                Key: { email },
              };
          
              try {
                const result = await ddbDocClient.send(new UpdateCommand(params));
                const data = await ddbDocClient.send(new GetCommand(getParams));
                if (!data.Item) {
                  return {
                    ...response,
                    statusCode: 404,
                    body: JSON.stringify({ message: 'User not found' }),
                  };
                }
          
                const { topicArn, firstName} = data.Item;
          
                // Send registration success email via SNS
                const publishParams = {
                  TopicArn: topicArn,
                  Message: `Welcome to Dal-Vacation-Home, ${firstName}. To get started, log in with your credentials and start exploring our services.`,
                  Subject: 'User Registration',
                };
          
                try {
                  await snsClient.send(new PublishCommand(publishParams));
                } catch (snsError) {
                  console.error('Error sending SNS message:', snsError);
                  // Handle the error appropriately, such as returning an error response
                  // console.error('Error sending registration success email', snsError);
                  // return {
                  //   ...response,
                  //   statusCode: 500,
                  //   body: { message: 'Error sending registration success email' }
                  // };
                }
          
                return {
                  ...response,
                  statusCode: 200,
                  body: JSON.stringify({ message: 'Security questions and secret key added successfully', updatedAttributes: result.Attributes })
                };
              } catch (error) {
                console.error('Error adding security questions:', error);
                return {
                  ...response,
                  statusCode: 500,
                  body: JSON.stringify({ message: `Error adding security questions: ${error.message}` })
                };
              }
            } else if (action === "fetch") {
              const { email, columns } = eventData.body;
          
              // Validate input
              if (!email || !columns || !Array.isArray(columns) || columns.length === 0) {
                return {
                  ...response,
                  statusCode: 400,
                  body: JSON.stringify({ message: 'Email and non-empty array of columns are required' }),
                };
              }
          
              const params = {
                TableName: 'User',
                Key: { email }
              };
          
              try {
                const data = await ddbDocClient.send(new GetCommand(params));
                if (!data.Item) {
                  return {
                    ...response,
                    statusCode: 404,
                    body: JSON.stringify({ message: 'User not found' })
                  };
                }
          
                const result = {};
                columns.forEach(column => {
                  if (data.Item[column]) {
                    result[column] = data.Item[column];
                  }
                });
          
                return {
                  ...response,
                  statusCode: 200,
                  body: JSON.stringify(result)
                };
              } catch (error) {
                console.error('Error fetching columns:', error);
                return {
                  ...response,
                  statusCode: 500,
                  body: JSON.stringify({ message: `Error fetching columns: ${error.message}` })
                };
              }
            } else {
              return {
                ...response,
                statusCode: 400,
                body: JSON.stringify({ message: 'Invalid action' })
              };
            }
          };

      Runtime: 'nodejs20.x'
      Timeout: 30
      Environment:
        Variables:
          USERS_TABLE_NAME: "User"

  SecondFactorFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt SecondFactorAuthentication.Arn
      Principal: apigateway.amazonaws.com

  ApiGatewayResourceSecondFactor:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'second-factor-auth'

  ApiGatewayMethodSecondFactor:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceSecondFactor
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceSecondFactor
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SecondFactorAuthentication.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  ApiGatewayMethodOptionsSecondFactor:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceSecondFactor
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceSecondFactor
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'POST,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"


  #Done
  EmailVerification:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: 'index.handler'
      Role: !Ref RoleARN
      Code:
        ZipFile: |
          const { CognitoIdentityProviderClient, ConfirmSignUpCommand, ResendConfirmationCodeCommand } = require('@aws-sdk/client-cognito-identity-provider');
          
          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "OPTIONS,POST"
              }
            };
          
            // Extract parameters from the event
            const { action, email, verificationCode } = JSON.parse(event.body);
          
            // Create an instance of the Cognito Identity Provider client
            const client = new CognitoIdentityProviderClient({ region: 'us-east-1' });
          
            try {
              if (action === 'sendVerificationCode') {
                // Create a command to resend confirmation code
                const resendCommand = new ResendConfirmationCodeCommand({
                  ClientId: '7obkafbfl095gprlo6gli6je55',
                  Username: email,
                });
          
                // Send the resend command to Cognito
                const data = await client.send(resendCommand);
                console.log('Resend confirmation code response:', data);
          
                return {
                  ...response,
                  body: JSON.stringify({ message: 'Verification code sent successfully' })
                };
              } else if (action === 'verifyVerificationCode') {
                // Create a command to confirm the sign-up
                const confirmCommand = new ConfirmSignUpCommand({
                  ClientId: '7obkafbfl095gprlo6gli6je55',
                  Username: email,
                  ConfirmationCode: verificationCode
                });
          
                // Send the confirmation command to Cognito
                const data = await client.send(confirmCommand);
                console.log('Confirmation response:', data);
          
                // If confirmation is successful, data will contain relevant information
                return {
                  ...response,
                  body: JSON.stringify({ message: 'Email verification successful' })
                };
              } else {
                return {
                  ...response,
                  statusCode: 400,
                  body: JSON.stringify({ message: 'Invalid action specified' })
                };
              }
            } catch (error) {
              console.error('Error processing action:', error);
              return {
                ...response,
                statusCode: 500,
                body: JSON.stringify({ message: 'Error processing action', error: error.message })
              };
            }
          };
      Runtime: 'nodejs20.x'
      Timeout: 30
      Environment:
        Variables:
          COGNITO_CLIENT_ID: "7obkafbfl095gprlo6gli6je55"

  EmailVerificationFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt EmailVerification.Arn
      Principal: apigateway.amazonaws.com

  ApiGatewayResourceEmailVerification:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'email-verification'

  ApiGatewayMethodEmailVerification:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceEmailVerification
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters: {}
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceEmailVerification
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${EmailVerification.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  ApiGatewayMethodOptionsEmailVerification:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceEmailVerification
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceEmailVerification
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'POST,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"


  #Done
  SignUp:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: 'index.handler'
      Role: !Ref RoleARN
      Code:
        ZipFile: |
          const { CognitoIdentityProviderClient, SignUpCommand, AdminAddUserToGroupCommand } = require('@aws-sdk/client-cognito-identity-provider');
          const { DynamoDBClient, PutItemCommand } = require('@aws-sdk/client-dynamodb');
          const { CreateTopicCommand, SubscribeCommand, SNSClient } = require('@aws-sdk/client-sns');
          
          const snsClient = new SNSClient({ region: 'us-east-1' });
          const cognitoClient = new CognitoIdentityProviderClient({ region: 'us-east-1' });
          const ddbClient = new DynamoDBClient({ region: 'us-east-1' });
          
          const poolData = {
            UserPoolId: "us-east-1_D8LhOZMJq",
            ClientId: "7obkafbfl095gprlo6gli6je55",
          };
          
          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "OPTIONS,POST"
              }
            };
            const { password, email, firstName, lastName, groupToAdd } = JSON.parse(event.body); // used when testing from API Gateway
          
          
            // Validate input
            if (!password || !email || !firstName || !lastName) {
              return {
                ...response,
                statusCode: 400,
                body: JSON.stringify({ message: 'Password, email, first name, and last name are required' }),
              };
            }
          
            // Prepare attributes
            const attributeList = [
              { Name: 'email', Value: email },
              { Name: 'given_name', Value: firstName },
              { Name: 'family_name', Value: lastName },
            ];
          
            // Prepare sign-up parameters
            const signUpParams = {
              ClientId: poolData.ClientId,
              Password: password,
              Username: email,
              UserAttributes: attributeList,
            };
          
            try {
              const signUpData = await cognitoClient.send(new SignUpCommand(signUpParams));
              console.log('Sign up successful:', signUpData);
          
              // If user signed up successfully, assign them to a group
              const addUserToGroupParams = {
                GroupName: groupToAdd,
                Username: email,
                UserPoolId: poolData.UserPoolId,
              };
          
              await cognitoClient.send(new AdminAddUserToGroupCommand(addUserToGroupParams));
              console.log('User added to group:', groupToAdd);
          
              // Extract part of email before @ for topic name
              const userName = email.substring(0, email.indexOf('@'));
              const topicName = `topic-${userName}`;
          
              // Create an SNS topic with the modified topic name
              const createTopicParams = {
                Name: topicName,
              };
          
              // Generate a unique user_id
              const userId = signUpData.UserSub; // Using Cognito UserSub as user_id
              console.log('Creating SNS topic with name:', topicName);
          
              const createTopicResponse = await snsClient.send(new CreateTopicCommand(createTopicParams));
              const createdArn = createTopicResponse.TopicArn;
              console.log('SNS topic created:', createdArn);
          
              // Subscribe the user's email to the SNS topic
              const subscribeParams = {
                Protocol: 'email',
                Endpoint: email,
                TopicArn: createdArn,
              };
          
              await snsClient.send(new SubscribeCommand(subscribeParams));
              console.log(`Subscribed ${email} to topic:`, createdArn);
          
              // Store the user in DynamoDB
              const ddbParams = {
                TableName: 'User',
                Item: {
                  'user_id': { S: userId },
                  'email': { S: email },
                  'firstName': { S: firstName },
                  'password': { S: password },
                  'lastName': { S: lastName },
                  'topicArn': { S: createdArn }, // Store the created topic ARN in DynamoDB
                  'userType': {S: groupToAdd},
                }
              };
          
              await ddbClient.send(new PutItemCommand(ddbParams));
              console.log('User stored in DynamoDB with topic ARN:', createdArn);
          
              // Return success response
              return {
                ...response,
                statusCode: 200,
                body: JSON.stringify({ message: 'User signed up successfully', topicArn: createdArn }),
              };
            } catch (err) {
              console.error('Error signing up or adding user to group:', err);
              // Specific error handling
              let errorMessage = 'An error occurred while signing up the user.';
              if (err.name === 'UsernameExistsException') {
                errorMessage = 'An account with this email already exists.';
              } else if (err.name === 'InvalidPasswordException') {
                errorMessage = 'Password does not meet the required criteria.';
              } else if (err.name === 'InvalidParameterException') {
                errorMessage = 'Invalid parameter provided. Please check your input.';
              } else if (err.name === 'UserNotFoundException') {
                errorMessage = 'User not found.';
              } else if (err.name === 'NotAuthorizedException') {
                errorMessage = 'You are not authorized to perform this action.';
              } else if (err.name === 'ResourceNotFoundException') {
                errorMessage = 'The requested resource was not found.';
              }
          
              // Return error response
              return {
                ...response,
                statusCode: 500,
                body: JSON.stringify({ message: errorMessage }),
              };
            }
          };
      Runtime: 'nodejs20.x'
      Timeout: 30
      Environment:
        Variables:
          USER_POOL_ID: "us-east-1_D8LhOZMJq"
          COGNITO_CLIENT_ID: "7obkafbfl095gprlo6gli6je55"
          DDB_TABLE_NAME: "User"

  SignUpFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt SignUp.Arn
      Principal: apigateway.amazonaws.com

  ApiGatewayResourceSignUp:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'sign-up'

  ApiGatewayMethodSignUp:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceSignUp
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters: {}
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceSignUp
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SignUp.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  ApiGatewayMethodOptionsSignUp:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceSignUp
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceSignUp
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'POST,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"


  #Done
  ApiGatewayMethodOptionsRoot:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceRoot
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceRoot
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'OPTIONS,POST,GET'"  # Update this with the allowed methods
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            StatusCode: "200"
        PassthroughBehavior: "WHEN_NO_MATCH"
        RequestTemplates:
          "application/json": "{\"statusCode\": 200}"
        TimeoutInMillis: 29000
        Type: "MOCK"

  # OPTIONS method for the root resource
  ApiGatewayResourceRoot:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: "{proxy+}"



  #  done
  BookingSqsQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: BookingQueue123

  #  done
  ApproveBookingLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: ApproveBookingFunction
      Handler: index.lambda_handler
      Runtime: python3.8
      Role: !Ref RoleARN
      Environment:
        Variables:
          BOOKING_TABLE_NAME: "Booking"
          USER_TABLE_NAME: "User"
          ROOM_TABLE_NAME: "Room"
      Code:
        ZipFile: |
          import boto3
          import json
          from datetime import datetime, timedelta

          dynamodb = boto3.resource('dynamodb')
          booking_table = dynamodb.Table('Booking')
          user_table = dynamodb.Table('User')
          room_table = dynamodb.Table('Room')
          sns = boto3.client('sns')
          sns_topic_arn = ""

          def lambda_handler(event, context):
              try:
                  room_available = True 

                  sqs_record = event['Records'][0]
                  body = json.loads(sqs_record['body'])

                  booking_id = body.get('booking_id')
                  email = body.get('email')

                  booking_detail = booking_table.get_item(Key={'booking_id': booking_id})
                  request_item = booking_detail.get('Item')
          
                  if not request_item:
                      return {
                          'statusCode': 404,
                          'body': json.dumps('Booking request not found')
                      }
          
                  if request_item['status'] != 'pending':
                      return {
                          'statusCode': 400,
                          'body': json.dumps('Booking request has already been processed')
                      }

                  user_detail = user_table.get_item(Key={'email': email})
                  user_item = user_detail.get('Item')

                  if not user_item:
                      return {
                          'statusCode': 404,
                          'body': json.dumps('User not found')
                      }

                  sns_topic_arn = user_item.get('topicArn')
                  room_id = request_item['room_id']

                  room_detail = room_table.get_item(Key={'room_id': room_id})
                  room_item = room_detail.get('Item')

                  if not room_item:
                      return {
                          'statusCode': 404,
                          'body': json.dumps('Room not found')
                      }

                  check_in_date = datetime.strptime(request_item['check_in_date'], '%Y-%m-%d')
                  check_out_date = datetime.strptime(request_item['check_out_date'], '%Y-%m-%d')
          
                  booked_dates = room_item.get('booked_dates', [])
          
                  for booked_date in booked_dates:
                      booked_date = datetime.strptime(booked_date, '%Y-%m-%d')
                      if check_in_date <= booked_date <= check_out_date:
                          room_available = False
                          break

                  if room_available:
                      booking_table.update_item(
                          Key={'booking_id': booking_id},
                          UpdateExpression='SET #status = :status',
                          ExpressionAttributeNames={'#status': 'status'},
                          ExpressionAttributeValues={':status': 'confirmed'}
                      )
                      message_status = 'confirmed'
          
                      sns_message = f"Your booking was successful. The room is reserved from {request_item['check_in_date']} to {request_item['check_out_date']}. Enjoy your stay."
                      sns.publish(
                          TopicArn=sns_topic_arn,
                          Message=sns_message,
                          Subject='Room Booking Confirmation'
                      )

                      new_booked_dates = []
                      current_date = check_in_date
                      while current_date <= check_out_date:
                          new_booked_dates.append(current_date.strftime('%Y-%m-%d'))
                          current_date += timedelta(days=1)

                      room_item['booked_dates'].extend(new_booked_dates)
                      room_table.update_item(
                          Key={'room_id': room_id},
                          UpdateExpression='SET booked_dates = :booked_dates',
                          ExpressionAttributeValues={':booked_dates': room_item['booked_dates']}
                      )

                  else:
                      booking_table.update_item(
                          Key={'booking_id': booking_id},
                          UpdateExpression='SET #status = :status',
                          ExpressionAttributeNames={'#status': 'status'},
                          ExpressionAttributeValues={':status': 'denied'}
                      )

                      message_status = 'denied'

                      sns_message = f"Your room booking was unsuccessful. The room is already taken. We are sorry for your inconvenience."
                      sns.publish(
                          TopicArn=sns_topic_arn,
                          Message=sns_message,
                          Subject='Room Booking Unsuccessful'
                      )

                  return {
                      'statusCode': 200,
                      'body': json.dumps(f'Booking request {message_status} and notifications sent')
                  }

              except Exception as e:
                  booking_table.update_item(
                      Key={'booking_id': booking_id},
                      UpdateExpression='SET #status = :status',
                      ExpressionAttributeNames={'#status': 'status'},
                      ExpressionAttributeValues={':status': 'denied'}
                  )

                  message_status = 'denied'

                  sns_message = f"Your room booking was unsuccessful. The room is already taken. We are sorry for your inconvenience."
                  sns.publish(
                      TopicArn=sns_topic_arn,
                      Message=sns_message,
                      Subject='Room Booking Unsuccessful'
                  )

                  return {
                      'statusCode': 200,
                      'body': json.dumps(f'Booking request {message_status} and notifications sent')
                  }
  

  #  done
  LambdaSQSTrigger:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      BatchSize: 1
      EventSourceArn: !GetAtt BookingSqsQueue.Arn
      FunctionName: !GetAtt ApproveBookingLambda.Arn
      Enabled: true




  #Done
  RequestBookingFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: RequestBookingFunction
      Handler: index.lambda_handler
      Runtime: python3.8
      Role: !Ref RoleARN
      Timeout: 30
      Environment:
        Variables:
          BOOKING_TABLE_NAME: "Booking"
          USER_TABLE_NAME: "User"
          ROOM_TABLE_NAME: "Room"
      Code:
        ZipFile: |
          import boto3
          import json
          import uuid
          from datetime import datetime
          
          # Initialize DynamoDB client
          dynamodb = boto3.resource('dynamodb')
          table_name = 'Booking'
          table = dynamodb.Table(table_name)
          
          
          # Initialize SQS client
          sqs = boto3.client('sqs')
          sqs_queue_url = 'https://sqs.us-east-1.amazonaws.com/705544929821/BookingQueue'
          
          def lambda_handler(event, context):
              try:
                  if 'body' in event:
                      event_body = json.loads(event['body'])
                  else:
                      # Handle event from other sources
                      event_body = event
              except (KeyError, json.JSONDecodeError) as e:
                  return {
                      'statusCode': 400,
                      'body': json.dumps('Invalid input data format')
                  }
          
              email = event_body.get('email')
              room_id = event_body.get('room_id')
              check_in_date = event_body.get('check_in_date')
              check_out_date = event_body.get('check_out_date')
          
              # basic Validation
              if not email or not room_id or not check_in_date or not check_out_date:
                  return {
                      'statusCode': 400,
                      'body': json.dumps('Missing required fields: email, room_id, check_in_date, check_out_date')
          
                  }
          
              # Generating a unique booking request ID
              booking_id = str(uuid.uuid4())
          
              # Format dates
              check_in_iso = datetime.strptime(check_in_date, '%Y-%m-%d').strftime('%Y-%m-%d')
              check_out_iso = datetime.strptime(check_out_date, '%Y-%m-%d').strftime('%Y-%m-%d')
          
          
              request_item = {
                  'booking_id': booking_id,
                  'email': email,
                  'room_id': room_id,
                  'check_in_date': check_in_iso,
                  'check_out_date': check_out_iso,
                  'status': 'pending'  # Initial status when request is created
              }
          
              try:
                  # Insert booking request into DynamoDB
                  table.put_item(Item=request_item)
          
          
                  # add to queue
                  sqs_message = {
                      'booking_id': booking_id, 
                      'email' : email
                  }
                  sqs.send_message(
                      QueueUrl=sqs_queue_url,
                      MessageBody=json.dumps(sqs_message)
                  )
          
                  # Return success response
                  return {
                      'statusCode': 200,
                      'body': json.dumps({'message':'Room booking request submitted successfully', 'booking_id': booking_id})
                  }
              except Exception as e:
                  # Return error response
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error: {str(e)}')
                  }
  
  
  
  
  

  RequestBookingFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt RequestBookingFunction.Arn
      Principal: apigateway.amazonaws.com

  ApiGatewayResourceRequestBooking:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'request-booking'

  ApiGatewayMethodRequestBooking:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceRequestBooking
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceRequestBooking
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${RequestBookingFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  ApiGatewayMethodOptionsRequestBooking:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceRequestBooking
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceRequestBooking
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'POST,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"





  #Done
  GetRoom:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: index.lambda_handler
      Runtime: python3.8
      Role: !Ref RoleARN
      Timeout: 30
      Environment:
        Variables:
          BOOKING_TABLE_NAME: "Booking"
          USER_TABLE_NAME: "User"
          ROOM_TABLE_NAME: "Room"
      Code:
        ZipFile: |
          import json
          import boto3
          from decimal import Decimal
          
          def decimal_default(obj):
              if isinstance(obj, Decimal):
                  return float(obj)
              raise TypeError
          
          def lambda_handler(event, context):
              # Initialize DynamoDB resource
              dynamodb = boto3.resource('dynamodb')
              table = dynamodb.Table('Room')
          
              # Initialize S3 client
              s3_client = boto3.client('s3')
              bucket_name = 'room-images-dal'
          
              try:
                  # Scan the table to get all room details
                  response = table.scan()
                  rooms = response.get('Items', [])
          
                  # Fetch images for each room from S3
                  for room in rooms:
                      image_urls = []
                      room_id = room['room_id']  # Access directly
                      s3_folder_path = f'{room_id}/'
          
                      # List objects in the S3 folder
                      s3_response = s3_client.list_objects_v2(Bucket=bucket_name, Prefix=s3_folder_path)
                      if 'Contents' in s3_response:
                          for obj in s3_response['Contents']:
                              if obj['Key'] != s3_folder_path:    
                                  image_url = s3_client.generate_presigned_url('get_object', Params={'Bucket': bucket_name, 'Key': obj['Key']})
                                  image_urls.append(image_url)
          
                      # Add image URLs to room details
                      room['images'] = image_urls
          
                  return {
                      'statusCode': 200,
                      'body': json.dumps(rooms, default=decimal_default)
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error fetching room details: {str(e)}')
                  }





  GetRoomInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt GetRoom.Arn
      Principal: apigateway.amazonaws.com

  ApiGatewayResourceGetRoom:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'get-room'

  ApiGatewayMethodGetRoom:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceGetRoom
      HttpMethod: GET
      AuthorizationType: NONE
      ApiKeyRequired: false
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceGetRoom
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetRoom.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  ApiGatewayMethodOptionsGetRoom:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceGetRoom
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceGetRoom
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'GET,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"





  #Done python
  EditRoomFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: EditRoomFunction
      Handler: index.lambda_handler
      Runtime: python3.8
      Role: !Ref RoleARN
      Timeout: 30
      Environment:
        Variables:
          BOOKING_TABLE_NAME: "Booking"
          USER_TABLE_NAME: "User"
          ROOM_TABLE_NAME: "Room"
      Code:
        ZipFile: |
          import json
          import boto3
          
          def lambda_handler(event, context):
              # Initialize DynamoDB resource
              dynamodb = boto3.resource('dynamodb')
              table = dynamodb.Table('Room')
              try:
                if 'body' in event:
                    event_body = json.loads(event['body'])
                else:
                    # Handle event from other sources
                    event_body = event
              except (KeyError, json.JSONDecodeError) as e:
                return {
                    'statusCode': 400,
                    'body': json.dumps('Invalid input data format')
                }
          
              # Extract input parameters from the event
              room_id = event_body.get('room_id')
              about = event_body.get('about')
              booked_dates = event_body.get('booked_dates')
              facilities = event_body.get('facilities')
              max_guests = event_body.get('max_guests')
              no_of_baths = event_body.get('no_of_baths')
              no_of_beds = event_body.get('no_of_beds')
              price = event_body.get('price')
              room_name = event_body.get('room_name')
              room_type = event_body.get('room_type')
          
              # Validate the inputs
              if not room_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps('room_id is required')
                  }
          
              update_expression = 'SET '
              expression_attribute_values = {}
              if about:
                  update_expression += 'about = :about, '
                  expression_attribute_values[':about'] = about
              if booked_dates:
                  update_expression += 'booked_dates = :booked_dates, '
                  expression_attribute_values[':booked_dates'] = booked_dates
              if facilities:
                  update_expression += 'facilities = :facilities, '
                  expression_attribute_values[':facilities'] = facilities
              if max_guests:
                  update_expression += 'max_guests = :max_guests, '
                  expression_attribute_values[':max_guests'] = max_guests
              if no_of_baths:
                  update_expression += 'no_of_baths = :no_of_baths, '
                  expression_attribute_values[':no_of_baths'] = no_of_baths
              if no_of_beds:
                  update_expression += 'no_of_beds = :no_of_beds, '
                  expression_attribute_values[':no_of_beds'] = no_of_beds
              if price:
                  update_expression += 'price = :price, '
                  expression_attribute_values[':price'] = price
              if room_name:
                  update_expression += 'room_name = :room_name, '
                  expression_attribute_values[':room_name'] = room_name
              if room_type:
                  update_expression += 'room_type = :room_type, '
                  expression_attribute_values[':room_type'] = room_type
          
              # Remove trailing comma and space
              update_expression = update_expression.rstrip(', ')
          
              # Update the item in the DynamoDB table
              try:
                  table.update_item(
                      Key={'room_id': room_id},
                      UpdateExpression=update_expression,
                      ExpressionAttributeValues=expression_attribute_values
                  )
                  return {
                      'statusCode': 200,
                      'body': json.dumps('Room updated successfully')
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error updating room: {str(e)}')
                  }
  
  
  
  
  

  EditRoomInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt EditRoomFunction.Arn
      Principal: apigateway.amazonaws.com

  ApiGatewayResourceEditRoom:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'edit-room'

  ApiGatewayMethodEditRoom:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceEditRoom
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceEditRoom
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${EditRoomFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  ApiGatewayMethodOptionsEditRoom:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceEditRoom
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceEditRoom
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'POST,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"

  # DONE
  DeleteRoomFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: DeleteRoomFunction
      Handler: index.lambda_handler
      Runtime: python3.8
      Role: !Ref RoleARN
      Timeout: 30
      Environment:
        Variables:
          BOOKING_TABLE_NAME: "Booking"
          USER_TABLE_NAME: "User"
          ROOM_TABLE_NAME: "Room"
      Code:
        ZipFile: |
          import json
          import boto3
          
          def lambda_handler(event, context):
              # Initialize DynamoDB resource
              dynamodb = boto3.resource('dynamodb')
              table = dynamodb.Table('Room')
              try:
                if 'body' in event:
                    event_body = json.loads(event['body'])
                else:
                    # Handle event from other sources
                    event_body = event
              except (KeyError, json.JSONDecodeError) as e:
                return {
                    'statusCode': 400,
                    'body': json.dumps('Invalid input data format')
                }
          
              # Extract the room_id from the event
              room_id = event_body.get('room_id')
          
              # Validate the input
              if not room_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps('room_id is required')
                  }
          
              # Delete the item from the DynamoDB table
              try:
                  table.delete_item(Key={'room_id': room_id})
                  return {
                      'statusCode': 200,
                      'body': json.dumps('Room deleted successfully')
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error deleting room: {str(e)}')
                  }









  DeleteRoomInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt DeleteRoomFunction.Arn
      Principal: apigateway.amazonaws.com

  ApiGatewayResourceDeleteRoom:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'delete-room'

  ApiGatewayMethodDeleteRoom:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceDeleteRoom
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceDeleteRoom
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${DeleteRoomFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  ApiGatewayMethodOptionsDeleteRoom:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceDeleteRoom
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceDeleteRoom
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'POST,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"


  #Done python
  AddRoomFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: AddRoomFunction
      Handler: index.lambda_handler
      Runtime: python3.8
      Role: !Ref RoleARN
      Timeout: 30
      Environment:
        Variables:
          BOOKING_TABLE_NAME: "Booking"
          USER_TABLE_NAME: "User"
          ROOM_TABLE_NAME: "Room"
      Code:
        ZipFile: |
          import json
          import boto3
          import uuid
          
          def lambda_handler(event, context):
              # Initialize DynamoDB resource
              dynamodb = boto3.resource('dynamodb')
              table = dynamodb.Table('Room')
          
              # Generate a unique room_id
              room_id = str(uuid.uuid4())
              try:
                if 'body' in event:
                    event_body = json.loads(event['body'])
                else:
                    # Handle event from other sources
                    event_body = event
              except (KeyError, json.JSONDecodeError) as e:
                return {
                    'statusCode': 400,
                    'body': json.dumps('Invalid input data format')
                }
          
              # Extract input parameters from the event
              about = event_body.get('about')
              booked_dates = event_body.get('booked_dates', [])
              facilities = event_body.get('facilities', [])
              max_guests = event_body.get('max_guests')
              no_of_baths = event_body.get('no_of_baths')
              no_of_beds = event_body.get('no_of_beds')
              price = event_body.get('price')
              room_name = event_body.get('room_name')
              room_type = event_body.get('room_type')
          
              # Validate the inputs
              if not all([about, max_guests, no_of_baths, no_of_beds, price, room_name, room_type]):
                  return {
                      'statusCode': 400,
                      'body': json.dumps('Missing required fields')
                  }
          
              # Prepare the item to be inserted
              item = {
                  'room_id': room_id,
                  'about': about,
                  'booked_dates': booked_dates,
                  'facilities': facilities,
                  'max_guests': max_guests,
                  'no_of_baths': no_of_baths,
                  'no_of_beds': no_of_beds,
                  'price': price,
                  'room_name': room_name,
                  'room_type': room_type,
              }
          
              # Insert the item into the DynamoDB table
              try:
                  table.put_item(Item=item)
                  return {
                      'statusCode': 200,
                      'body': json.dumps('Room added successfully')
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error adding room: {str(e)}')
                  }
  
  
  
  
  


  AddRoomInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt AddRoomFunction.Arn
      Principal: apigateway.amazonaws.com

  ApiGatewayResourceAddRoom:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'add-room'

  ApiGatewayMethodAddRoom:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceAddRoom
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceAddRoom
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${AddRoomFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  ApiGatewayMethodOptionsAddRoom:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceAddRoom
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceAddRoom
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'POST,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"


  #Done python
  GetUserBookingFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Description: "GetUserBookings1234"
      FunctionName: "GetUserBookings1234"
      Handler: "lambda_function.lambda_handler"
      Architectures:
        - "x86_64"
      MemorySize: 128
      Role: !Ref RoleARN
      Runtime: "python3.9"
      Timeout: 30
      TracingConfig:
        Mode: "PassThrough"
      EphemeralStorage:
        Size: 512
      Code:
        ZipFile: |
          import json
          import boto3
          from boto3.dynamodb.conditions import Attr
          
          dynamodb = boto3.resource('dynamodb')
          TABLE_NAME = 'Booking'
          def lambda_handler(event, context):
              print("Event: ", event)
          
              if 'body' in event:
                  try:
                      body = json.loads(event['body'])
                      email = body.get('email', None)
                  except json.JSONDecodeError:
                      return {
                          'statusCode': 400,
                          'body': json.dumps({'error': 'Invalid JSON in request body'})
                      }
              else:
                  email = event.get('queryStringParameters', {}).get('email', None)
          
              if not email:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'Email is required'})
                  }
          
              table = dynamodb.Table(TABLE_NAME)
          
              try:
                  response = table.scan(
                      FilterExpression=Attr('email').eq(email)
                  )
          
                  return {
                      'statusCode': 200,
                      'body': json.dumps(response['Items'])
                  }
          
              except Exception as e:
                  print(f"Error querying DynamoDB: {e}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': 'Could not fetch bookings'})
                  }



  GetUserBookingPermission:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunctionUrl"
      FunctionName: !GetAtt GetUserBookingFunction.Arn
      Principal:  !Ref RoleARN

  GetUserBookingUrl:
    Type: "AWS::Lambda::Url"
    Properties:
      TargetFunctionArn: !GetAtt GetUserBookingFunction.Arn
      AuthType: "NONE"
      Cors:
        AllowCredentials: false
        AllowHeaders:
          - "*"
        AllowMethods:
          - "POST"
        AllowOrigins:
          - "*"
        MaxAge: 60


  #Done python
  GetBookingDetailsFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Description: "GetBookingDetailss1234"
      FunctionName: "GetBookingDetailss1234"
      Handler: "lambda_function.lambda_handler"
      Architectures:
        - "x86_64"
      MemorySize: 128
      Role: !Ref RoleARN
      Runtime: "python3.9"
      Timeout: 30
      TracingConfig:
        Mode: "PassThrough"
      EphemeralStorage:
        Size: 512
      Code:
        ZipFile: |
          import json
          import boto3
          from botocore.exceptions import ClientError
          import requests
          
          def lambda_handler(event, context):
              bot = event['bot']['name']
              intent = event['sessionState']['intent']['name']
              slots = event['sessionState']['intent']['slots']
              user_id = event['sessionId'] 
              print("slots: ", slots)
              print("session ID: ", user_id)
          
              # Initialize a DynamoDB client
              dynamodb = boto3.client('dynamodb')
          
              if intent == 'GetBookingDetails':
                  booking_id = slots['BookingID']['value']['originalValue']
          
                  if not booking_id:
                      return {
                          'sessionState': {
                              'intent': {
                                  'name': intent,
                              },
                              'dialogAction': {
                                  'type': 'ElicitSlot',
                                  'slotToElicit': 'BookingID'
                              }
                          },
                          'messages': [
                              {
                                  'contentType': 'PlainText',
                                  'content': 'BookingID slot is required but not provided'
                              }
                          ]
                      }
          
                  try:
                      response = dynamodb.get_item(
                          TableName='Booking',
                          Key={'booking_id': {'S': booking_id}}
                      )
          
                      if 'Item' in response:
                          item = response['Item']
                          check_in_date = item['check_in_date']['S']
                          check_out_date = item['check_out_date']['S']
                          email = item['email']['S']
                          room_id = item['room_id']['S']
                          status = item['status']['S']
          
                          message = (f"Booking ID {booking_id} Details:\n"
                                     f"Check-In Date: {check_in_date}\n"
                                     f"Check-Out Date: {check_out_date}\n"
                                     f"Email: {email}\n"
                                     f"Room ID: {room_id}\n"
                                     f"Status: {status}")
                      else:
                          message = f"Booking ID {booking_id} not found."
          
                  except ClientError as e:
                      message = f"Error fetching booking details: {e.response['Error']['Message']}"
          
              elif intent == 'TalkToAgent':
                  customer_issue = slots.get('CustomerIssue', {}).get('value', {}).get('originalValue', '')
                  print("customer issue: ", customer_issue)
          
                  if customer_issue:
                      # Split the customer_issue string and assign to variables
                      issue_parts = customer_issue.split(', ')
                      if len(issue_parts) == 4:
                          booking_id, concern, email_address, user_name = issue_parts
                          message = (f"Thank you for reaching out, {user_name}. An agent will contact you at {email_address} "
                                     f"regarding the issue with Booking ID {booking_id}: {concern}.")
                          payload = {
                              "bookingId": booking_id,
                              "concern": concern,
                              "userId": user_id,
                              "userEmail": email_address,
                              "userName": user_name
                          }
          
                          # Make the API call
                          api_url = 'https://us-central1-dal-vacation-home-429313.cloudfunctions.net/publishMessage'
                          headers = {'Content-Type': 'application/json'}
                          try:
                              response = requests.post(api_url, headers=headers, data=json.dumps(payload))
                              if response.status_code == 200:
                                  message = f"Thank you for reaching out, {user_name}. An agent will contact you at {email_address} regarding the issue with Booking ID {booking_id}: {concern}."
                              else:
                                  message = f"Failed to publish message. Status code: {response.status_code}"
                          except requests.RequestException as e:
                              message = f"Error making the API call: {str(e)}"
                      else:
                          message = "The CustomerIssue value is not in the correct format."
                  else:
                      message = "No CustomerIssue provided."
          
              else:
                  message = "Unsupported intent"
          
              return {
                  'sessionState': {
                      'intent': {
                          'name': intent,
                      },
                      'dialogAction': {
                          'type': 'ElicitIntent'
                      }
                  },
                  'messages': [
                      {
                          'contentType': 'PlainText',
                          'content': message
                      }
                  ]
              }






  GetBookingDetailsPermission:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunctionUrl"
      FunctionName: !GetAtt GetBookingDetailsFunction.Arn
      Principal: !Ref RoleARN

  GetBookingDetailsUrl:
    Type: "AWS::Lambda::Url"
    Properties:
      TargetFunctionArn: !GetAtt GetBookingDetailsFunction.Arn
      AuthType: "NONE"
      Cors:
        AllowCredentials: false
        AllowHeaders:
          - "*"
        AllowMethods:
          - "POST"
        AllowOrigins:
          - "*"
        MaxAge: 60



  #Done python
  LogUserLoginRDSFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Description: "LogUserLoginRDSs1234"
      FunctionName: "LogUserLoginRDSs1234"
      Handler: "lambda_function.lambda_handler"
      Architectures:
        - "x86_64"
      MemorySize: 128
      Role: !Ref RoleARN
      Runtime: "python3.9"
      Timeout: 30
      TracingConfig:
        Mode: "PassThrough"
      EphemeralStorage:
        Size: 512
      Code:
        ZipFile: |
          import os
          import json
          import mysql.connector
          from mysql.connector import Error
          from datetime import datetime
          
          rds_host = "user-details.cirqdoltkjgp.us-east-1.rds.amazonaws.com"
          rds_username = ""
          rds_password = ""
          rds_db_name = "userDetails"
          
          def connect_to_rds():
              try:
                  connection = mysql.connector.connect(
                      host=rds_host,
                      user=rds_username,
                      password=rds_password,
                      database=rds_db_name
                  )
                  return connection
              except Error as e:
                  print(f"ERROR: Could not connect to MySQL instance. {e}")
                  raise
          
          def log_user_login(cursor, email):
              login_date = datetime.now().strftime('%Y-%m-%d')
              login_time = datetime.now().strftime('%H:%M:%S')
          
              sql = """
                  INSERT INTO logs (email, login_date, login_time)
                  VALUES (%s, %s, %s)
              """
              cursor.execute(sql, (email, login_date, login_time))
          
          def set_user_active(cursor, email):
              sql = """
                  UPDATE users
                  SET is_active = TRUE
                  WHERE email = %s
              """
              cursor.execute(sql, (email,))
          
          def lambda_handler(event, context):
              connection = connect_to_rds()
              cursor = connection.cursor()
              print(event)
          
              #email = event['email']
              body = json.loads(event['body'])
              email = body['email']
              log_user_login(cursor, email)
              set_user_active(cursor, email)
          
              connection.commit()
              cursor.close()
              connection.close()
          
              return {
                  'statusCode': 200,
                  'body': json.dumps('Login event logged successfully')
              }





  LogUserLoginRDSPermission:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunctionUrl"
      FunctionName: !GetAtt LogUserLoginRDSFunction.Arn
      Principal: !Ref RoleARN

  LogUserLoginRDSUrl:
    Type: "AWS::Lambda::Url"
    Properties:
      TargetFunctionArn: !GetAtt LogUserLoginRDSFunction.Arn
      AuthType: "NONE"
      Cors:
        AllowCredentials: false
        AllowHeaders:
          - "*"
        AllowMethods:
          - "POST"
        AllowOrigins:
          - "*"
        MaxAge: 60


  #Done python
  SetUserInActiveFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Description: "SetUserInActives1234"
      FunctionName: "SetUserInActives1234"
      Handler: "lambda_function.lambda_handler"
      Architectures:
        - "x86_64"
      MemorySize: 128
      Role: !Ref RoleARN
      Runtime: "python3.9"
      Timeout: 30
      TracingConfig:
        Mode: "PassThrough"
      EphemeralStorage:
        Size: 512
      Code:
        ZipFile: |
          import os
          import json
          import mysql.connector
          from mysql.connector import Error
          
          rds_host = "user-details.cirqdoltkjgp.us-east-1.rds.amazonaws.com"
          rds_username = ""
          rds_password = ""
          rds_db_name = "userDetails"
          
          def connect_to_rds():
              try:
                  connection = mysql.connector.connect(
                      host=rds_host,
                      user=rds_username,
                      password=rds_password,
                      database=rds_db_name
                  )
                  return connection
              except Error as e:
                  print(f"ERROR: Could not connect to MySQL instance. {e}")
                  raise
          
          def set_user_inactive(cursor, email):
              sql = """
                  UPDATE users
                  SET is_active = FALSE
                  WHERE email = %s
              """
              cursor.execute(sql, (email,))
          
          def lambda_handler(event, context):
              connection = connect_to_rds()
              cursor = connection.cursor()
              print(event)
          
              body = json.loads(event['body'])
              email = body['email']
          
              set_user_inactive(cursor, email)
          
              connection.commit()
              cursor.close()
              connection.close()
          
              return {
                  'statusCode': 200,
                  'body': json.dumps('Logout event logged successfully, user set to inactive')
              }




  SetUserInActivePermission:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunctionUrl"
      FunctionName: !GetAtt SetUserInActiveFunction.Arn
      Principal: !Ref RoleARN

  SetUserInActiveUrl:
    Type: "AWS::Lambda::Url"
    Properties:
      TargetFunctionArn: !GetAtt SetUserInActiveFunction.Arn
      AuthType: "NONE"
      Cors:
        AllowCredentials: false
        AllowHeaders:
          - "*"
        AllowMethods:
          - "POST"
        AllowOrigins:
          - "*"
        MaxAge: 60


  #Done python
  InsertUserToRDSFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Handler: "lambda_function.lambda_handler"
      Architectures:
        - "x86_64"
      MemorySize: 128
      Role: !Ref RoleARN
      Runtime: "python3.9"
      Timeout: 30
      TracingConfig:
        Mode: "PassThrough"
      EphemeralStorage:
        Size: 512
      Code:
        ZipFile: |
          import os
          import json
          import mysql.connector
          from mysql.connector import errorcode
          
          rds_host = "user-details.cirqdoltkjgp.us-east-1.rds.amazonaws.com"
          rds_username = ""
          rds_password = ""
          rds_db_name = "userDetails"
          
          def connect_to_rds():
              try:
                  connection = mysql.connector.connect(
                      host=rds_host,
                      user=rds_username,
                      password=rds_password,
                      database=rds_db_name,
                      connect_timeout=5
                  )
                  return connection
              except mysql.connector.Error as err:
                  if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                      print("ERROR: Something is wrong with your user name or password")
                  elif err.errno == errorcode.ER_BAD_DB_ERROR:
                      print("ERROR: Database does not exist")
                  else:
                      print(err)
                  raise
          
          def insert_user_to_rds(cursor, user):
              email = user['email']['S']
              firstName = user['firstName']['S']
              lastName = user['lastName']['S']
              userType = user['userType']['S'] if 'userType' in user else 'registered-users'
              is_active = 0
          
              sql = """
                  INSERT INTO users (email, firstName, lastName, userType, is_active)
                  VALUES (%s, %s, %s, %s, %s)
                  ON DUPLICATE KEY UPDATE
                      firstName = VALUES(firstName),
                      lastName = VALUES(lastName),
                      userType = VALUES(userType),
                      is_active = VALUES(is_active)
              """
              cursor.execute(sql, (email, firstName, lastName, userType, is_active))
          
          def lambda_handler(event, context):
              connection = connect_to_rds()
              cursor = connection.cursor()
          
              for record in event['Records']:
                  if record['eventName'] == 'INSERT':
                      new_user = record['dynamodb']['NewImage']
                      insert_user_to_rds(cursor, new_user)
          
              connection.commit()
              cursor.close()
              connection.close()
          
              return {
                  'statusCode': 200,
                  'body': json.dumps('Success')
              }




  InsertUserToRDSPermission:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunctionUrl"
      FunctionName: !GetAtt InsertUserToRDSFunction.Arn
      Principal: !Ref RoleARN

  InsertUserToRDSUrl:
    Type: "AWS::Lambda::Url"
    Properties:
      TargetFunctionArn: !GetAtt InsertUserToRDSFunction.Arn
      AuthType: "NONE"
      Cors:
        AllowCredentials: false
        AllowHeaders:
          - "*"
        AllowMethods:
          - "POST"
        AllowOrigins:
          - "*"
        MaxAge: 60


  ApiGatewayDeployment:
    Type: 'AWS::ApiGateway::Deployment'
    DependsOn:
      - ApiGatewayMethodUserAuth
      - ApiGatewayMethodOptionsUserAuth
      - ApiGatewayMethodSecretKeyVerification
      - ApiGatewayMethodOptionsSecretKeyVerification
      - ApiGatewayMethodSecondFactor
      - ApiGatewayMethodOptionsSecondFactor
      - ApiGatewayMethodEmailVerification
      - ApiGatewayMethodOptionsEmailVerification
      - ApiGatewayMethodSignUp
      - ApiGatewayMethodOptionsSignUp

      - ApiGatewayMethodRequestBooking
      - ApiGatewayMethodOptionsRequestBooking
      - ApiGatewayMethodGetRoom
      - ApiGatewayMethodOptionsGetRoom
      - ApiGatewayMethodEditRoom
      - ApiGatewayMethodOptionsEditRoom
      - ApiGatewayMethodOptionsDeleteRoom
      - ApiGatewayMethodDeleteRoom
      - ApiGatewayMethodOptionsAddRoom
      - ApiGatewayMethodAddRoom
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      StageName: !Ref Stage

Outputs:
  ApiUrl:
    Description: 'URL for the API endpoint'
    Value:
      Fn::Sub: "https://${ApiGatewayRestApi}.execute-api.${AWS::Region}.amazonaws.com/${Stage}/user-auth"
